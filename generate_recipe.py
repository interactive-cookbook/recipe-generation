import networkx as nx
import json
import penman
from pathlib import Path

from graph_processing.action_amr_graph_mappings import add_semantic_representations
from utils.paths import MODEL_DIR
from model.inference import RecipeGenerator
from amr_processing.penman_networkx_conversions import networkx2penman
from graph_processing.recipe_graph import read_graph_from_conllu

"""
Functions to generate a recipe by traversing an action graph and generating a sentence
for each action node from its amr graph and the previous sentence
"""

# TODO documentation


def generate(amr_graph: nx.DiGraph, context: list, generator: RecipeGenerator):
    """
    Generates a sentence for an amr graph based on context
    :param amr_graph: an AMR graph as networkx graph
    :param context: list with the previously generated sentences or empty list if no context
    :param generator: an instantiated RecipeGenerator object
    :return: the sentence generated by RecipeGenerator.model from the amr and the context
    """
    # need to convert networkx graph into string representation
    penman_amr = networkx2penman(amr_graph)
    amr_graph_str = penman.encode(penman_amr, indent=0)
    amr_graph_str = amr_graph_str.replace('\n', ' ')
    model_output = generator.generate([context], [amr_graph_str])
    return model_output


def generate_recipe_ac_graph(action_graph: nx.DiGraph, generation_config, context_len: int = 1):
    """
    Generates a recipe for an action graph
    :param action_graph: an action graph (networkx object)
    :param generation_config: a .json file with the configuration parameters for the generation model to use
    :param context_len: the context length, i.e. how many previous sentences to consider
    :return:
    """
    generated_sentences = []
    already_realized_amrs = []

    # load the model and instantiate inference class object
    print("---------- Loading Recipe Generator ----------")
    with open(generation_config, 'r', encoding='utf-8') as c:
        configuration_dict = json.load(c)
    generator = RecipeGenerator(configuration_dict)

    # add the corresponding amr graphs
    print("---------- Loading Semantic Representations ----------")
    sem_action_graph = add_semantic_representations(action_graph)

    # create an order of the action graphs
    action_ordering = order_actions_df(sem_action_graph)

    # loop through the ordered action nodes
    print("---------- Starting Generation ----------")
    for action_node in action_ordering:
        # get semantic representation of action node
        sem_repr = nx.get_node_attributes(sem_action_graph, 'amr')[action_node]
        # skip unaligned action nodes
        if not sem_repr:
            continue
        amr_id = sem_repr.graph['id']
        # skip already covered amr graphs
        if amr_id in already_realized_amrs:
            continue

        if context_len == 0:
            context_sentences = []
        else:
            context_sentences = generated_sentences[-context_len:]
        # run generation
        gen_snt = generate(sem_repr, context_sentences, generator)

        generated_sentences.extend(gen_snt)
        already_realized_amrs.append(amr_id)

    print("---------- Finished Generation ----------")
    print(action_ordering)
    print(already_realized_amrs)
    return generated_sentences


def order_actions_topological(action_graph: nx.Graph):
    """
    Orders all nodes of the input graph topologically
    :param action_graph:
    :return: List of ordered nodes of action_graph
    """
    ordered_actions = list(nx.topological_sort(action_graph))
    return ordered_actions


def order_actions_df(action_graph: nx.DiGraph):
    """
    Orders all nodes from the input graph in a the following way
    1. start with a "root" node
    2. continue with the child node if a) child has no other parent nodes or b) all parent nodes are already covered
    3. If child node has other not yet covered parents, choose a "root" node which has a path to an uncovered parent node
    4. Continue 1. - 3. until all nodes are covered
    :param action_graph:
    :return: ordered list of all nodes of action_graph
    """
    all_nodes = set(action_graph.nodes)
    covered_nodes = set()
    potential_starts = []
    ordered_actions = []

    # find potential start nodes
    for n in action_graph.nodes():
        parent_nodes = list(action_graph.predecessors(n))
        if not parent_nodes:
            potential_starts.append(n)
    potential_starts.sort()

    current_node = potential_starts.pop(0)
    ordered_actions.append(current_node)
    covered_nodes.add(current_node)
    while len(covered_nodes) < len(all_nodes):
        # parser only produces trees, so each node has exactly one successor
        # except the 'end' node which has no successor but should be added last so loop is not entered for it
        child_nodes = list(action_graph.successors(current_node))
        assert len(child_nodes) == 1
        child_node = child_nodes[0]

        child_parents = list(action_graph.predecessors(child_node))
        all_parents_covered = True
        for cp in child_parents:
            if cp not in covered_nodes:     # found a not yet covered parent
                all_parents_covered = False
                next_start_node = None
                for node_ind, left_start_node in enumerate(potential_starts):
                    if list(nx.all_simple_paths(action_graph, left_start_node, child_node)):
                        next_start_node = left_start_node
                        potential_starts.pop(node_ind)
                        break

                assert next_start_node
                current_node = next_start_node
                ordered_actions.append(next_start_node)
                covered_nodes.add(next_start_node)
                break

        if all_parents_covered:
            ordered_actions.append(child_node)
            covered_nodes.add(child_node)
            current_node = child_node

    return ordered_actions


if __name__=='__main__':

    ac_graph = read_graph_from_conllu(Path('./data/ara1.1/waffles/recipes/waffles_2.conllu'))
    configuration_file = MODEL_DIR / Path('recipe_gen_config.json')
    recipe = generate_recipe_ac_graph(action_graph=ac_graph,
                             generation_config=configuration_file,
                             context_len=1)
    for s in recipe:
        print(s)

