import networkx as nx
import json
import penman
from pathlib import Path

from graph_processing.action_amr_graph_mappings import add_semantic_representations
from utils.paths import MODEL_DIR
from model.inference import RecipeGenerator
from amr_processing.penman_networkx_conversions import networkx2penman
from graph_processing.recipe_graph import read_graph_from_conllu
from graph_processing.graph_traversal import order_actions_df, order_actions_df_lf, order_actions_token_ids, \
    order_actions_topological

"""
Functions to generate a recipe by traversing an action graph and generating a sentence
for each action node from its amr graph and the previous sentence
"""


def prepare_input_amr_str(amr_graph: nx.DiGraph):
    """
    convert amr_graph into its string representation without metadata
    :param amr_graph:
    :return:
    """
    # convert to string in penman format without indentation, without line breaks and without metadata
    penman_amr = networkx2penman(amr_graph)
    penman_str = penman.encode(penman_amr, indent=0)

    penman_lines = penman_str.split('\n')
    cleaned_lines = [l for l in penman_lines if not l.startswith('# ::')]
    amr_graph_str = ' '.join(cleaned_lines)
    return amr_graph_str


def generate(amr_graph: nx.DiGraph, context: str, generator: RecipeGenerator):
    """
    Generates a sentence for an amr graph based on context
    :param amr_graph: an AMR graph as networkx graph
    :param context: list with the previously generated sentences or empty list if no context
    :param generator: an instantiated RecipeGenerator object
    :return: the sentence generated by RecipeGenerator.model from the amr and the context
    """
    # get input string format for amr graph
    amr_graph_str = prepare_input_amr_str(amr_graph)
    # generate function expects a list of contexts and list of amr graphs for handling batches
    model_output = generator.generate([context], [amr_graph_str])

    return model_output


def generate_recipe_ac_graph(action_graph: nx.DiGraph, generation_config, ordering: str = "df-lf", context_len: int = 1):
    """
    Generates a recipe for an action graph
    :param action_graph: an action graph (networkx object)
    :param generation_config: a .json file with the configuration parameters for the generation model to use
    :param ordering: the ordering function to use, can be "top", "ids", "df" and "df-lf"
    :param context_len: the context length, i.e. how many previous sentences to consider
    :return:
    """
    generated_sentences = []
    already_realized_amrs = []

    # load the model and instantiate inference class object
    print("---------- Loading Recipe Generator ----------")
    with open(generation_config, 'r', encoding='utf-8') as c:
        configuration_dict = json.load(c)
    generator = RecipeGenerator(configuration_dict)

    # add the corresponding amr graphs
    print("---------- Loading Semantic Representations ----------")
    sem_action_graph = add_semantic_representations(action_graph)

    # create an order of the action graphs
    if ordering == "top":
        action_ordering = order_actions_topological(sem_action_graph)
    elif ordering == "ids":
        action_ordering = order_actions_token_ids(sem_action_graph)
    elif ordering == "df":
        action_ordering = order_actions_df(sem_action_graph)
    elif ordering == "df-lf":
        action_ordering = order_actions_df_lf(sem_action_graph)
    else:
        raise ValueError('Ordering values can only be "top", "ids", "df" or "df-lf"')

    # loop through the ordered action nodes
    print("---------- Starting Generation ----------")
    for action_node in action_ordering:
        # get semantic representation of action node
        sem_repr = nx.get_node_attributes(sem_action_graph, 'amr')[action_node]
        # skip unaligned action nodes
        if not sem_repr:
            continue
        amr_id = sem_repr.graph['id']
        # skip already covered amr graphs
        if amr_id in already_realized_amrs:
            continue

        if context_len == 0:
            context_sentences = []
        else:
            context_sentences = generated_sentences[-context_len:]
        context = ' '.join(context_sentences)
        # run generation
        gen_snt = generate(sem_repr, context, generator)

        generated_sentences.extend(gen_snt)
        already_realized_amrs.append(amr_id)

    print("---------- Finished Generation ----------")
    print(action_ordering)
    print(already_realized_amrs)
    return generated_sentences


if __name__=='__main__':

    #ac_graph = read_graph_from_conllu(Path('./data/ara1.1/chewy_chocolate_chip_cookies/recipes/chewy_chocolate_chip_cookies_1.conllu'))
    ac_graph = read_graph_from_conllu(Path('./data/ara1.1/orange_chicken/recipes/orange_chicken_6.conllu'))

    configuration_file = MODEL_DIR / Path('recipe_gen_config.json')
    with open("orange_chicken_6_gente.txt", "w", encoding="utf-8") as f:
        recipe = generate_recipe_ac_graph(action_graph=ac_graph,
                                          generation_config=configuration_file,
                                          ordering="top",
                                          context_len=1)
        f.write("Topological Ordering: \n")
        for s in recipe:
            f.write(f'{s}\n')
        f.write('\n')

        recipe = generate_recipe_ac_graph(action_graph=ac_graph,
                                          generation_config=configuration_file,
                                          ordering="ids",
                                          context_len=1)
        f.write("Token ID Ordering: \n")
        for s in recipe:
            f.write(f'{s}\n')
        f.write('\n')

        recipe = generate_recipe_ac_graph(action_graph=ac_graph,
                                          generation_config=configuration_file,
                                          ordering="df",
                                          context_len=1)
        f.write("DF Ordering: \n")
        for s in recipe:
            f.write(f'{s}\n')
        f.write('\n')

        recipe = generate_recipe_ac_graph(action_graph=ac_graph,
                                          generation_config=configuration_file,
                                          ordering="df-lf",
                                          context_len=1)
        f.write("DF-LF Ordering: \n")
        for s in recipe:
            f.write(f'{s}\n')
        f.write('\n')


